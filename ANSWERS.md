Аутентификация По поводу JWT — технология хорошая, но пихать огромный токен в каждый запрос реально не всегда оправдано, особенно если в payload лежит куча данных/ролей и токен пухнет. В одном из проектов (в финтехе) мы вообще отказались от JWT в пользу stateful сессий (стандартная связка куки + Redis на бэке).

Выбрал бы я JWT сейчас? Да, если мы делаем микросервисы или публичный API для кучи разных клиентов (веб, мобилки). Там stateless природа JWT решает — микросервисам за гейтвеем не надо лезть в центральную базу при каждом запросе, чтобы понять, кто пришел. Но если делать проект, где критически важна безопасность и нужно уметь в любую секунду отрубить доступ юзеру (например, комп сперли, админ блочит аккаунт, либо пароль сменили), то JWT превращается в боль. Приходится городить костыли типа блэклистов в том же Редисе, и тогда вся суть stateless пропадает (ведь мы все равно ходим в кэш). В таких случаях я 100% выберу классические сессии, ими управлять намного проще.

Идентификация UUID как стандарт — крутая штука, решает проблему децентрализованной генерации айдишников и не дает спарсить данные перебором с инкрементальными ID.

Но на проде с ними бывали проблемы. Самое жесткое — когда мы использовали обычный случайный uuid v4 как primary key в Postgres. Записей стали миллионы, и инсерты начали жутко тормозить. Из-за того, что UUID абсолютно рандомный, новые строчки летят вразнобой по всему B-tree индексу, начинается лютая фрагментация и расщепление страниц памяти. База при вставках просто ложилась. В итоге пришлось переезжать на сортируемые айдишники (ULID / UUID v7), которые и уникальные, и монотонно возрастают по времени. Ну и банальный UX: если юзеру надо продиктовать номер заказа или тикета в саппорт по телефону, то длинный страшный uuid — это провал. Приходилось дополнительно генерить короткие человекочитаемые short-id чисто для фронта.

Организация кода NestJS с его DI, декораторами и модулями — мощно, но тоже со своими приколами.

Из реальной пользы: DI заставляет писать слабосвязанный код. Писать юнит-тесты на сервисы — вообще без проблем: подсунул мок базы или стороннего API в конструктор, и всё работает. Плюс круто, что валидация и проверка прав (гварды, пайпы) вынесены из контроллеров. Контроллер остается тупым роутером.

Но минусы тоже есть. Самая бесячая тема — циклические зависимости. Когда проект разрастается, постоянно ловишь ошибки на старте, потому что два модуля ссылаются друг на друга. Приходится лепить forwardRef, что само по себе костыль. Ну и оверхед: чтобы поднять простой CRUD на одну таблицу, надо насоздавать кучу файлов (модуль, контроллер, сервис, пару DTO). Для маленьких микросервисов, где логики почти нет, Express или Fastify зашли бы куда быстрее и проще.

Реактивность Концепция Реакта (изменил стейт — перерисовался UI) звучит красиво, пока не упрешься в сложный интерфейс.

Делали тяжелую админку с огромными таблицами данных, которые обновлялись по вебсокетам. И тут начался ад: по дефолту изменение стейта родителя дергает ре-рендер всего дерева вниз. Прилетает тик по сокету — интерфейс подвисает. Пришлось обвешивать абсолютно всё через React.memo, useCallback и useMemo. Код превратился в грязное месиво из хуков и оптимизаций. Плюс вечная боль с массивами зависимостей в хуках (stale closures — устаревшие замыкания). Забыл передать переменную в хук — получаешь баги со старыми данными, передал всё — получаешь бесконечный ре-рендер.

Для сравнения щупал Vue 3 (Composition API) и SolidJS — там точечная реактивность (на сигналах/прокси). Обновляется ровно тот узел DOM, который напрямую завязан на изменившийся стейт. Никакого диффинга всего гигантского виртуального DOM-а и никаких костылей с мемоизацией. Писать код кайфово. Да и HTMX в некоторых проектах заходил отлично — просто шлем куски нужного HTML с бэка и точечно подменяем, вообще снимает проблему сложного стейт-менеджмента на клиенте.
